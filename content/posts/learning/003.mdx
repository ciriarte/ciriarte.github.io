---
title: Learning Python | Modules
date: 2020-04-23
description: Python modules and how to tame them
tags:
  - python
  - learning
---

import { CodeWave } from "gatsby-theme-waves"

When we build programs sometimes they get big. The same way
we split little pieces of logic with [Methods, Functions and Classes](/learning-python-methods-vs-functions-vs-classes)
we might want to start segregating our code in multiple files, for
many reasons, the most common one is to reuse a piece
of code that we already wrote. Let's see how all that works.

When we writing the first few programs in earlier posts, we created
a file named like `cat.py` and then keep appending more code at the end
of the file.

Let's try to use our file in another program!

Create a new file by opening a terminal and type:

```bash
$ touch main.py
```

> Note: Whenever you see $ at the beginning of commands it
means it should be typed in your terminal.

Now let's add the following content to our file:

```python
import cat
```

Now let's run our new script:

```bash
$ python main.py
ฅ^•ﻌ•^ฅ Meoooooooow
ฅ^•ﻌ•^ฅ Meow
ฅ^•ﻌ•^ฅ Meoooow

ฅ^•ﻌ•^ฅ Meooooow
ฅ^•ﻌ•^ฅ Meoow
ฅ^•ﻌ•^ฅ Meoooooooooow

a == b Not the same Cat!

a == a Same Cat

b == b Same Cat

a == b It's not the same cat!

a == a It's the same cat!
```

What we're seeing is the output of `cat.py`. Why is that? When we use other imports
we usually don't get this kind of output!

When Python reads our file it starts "interpreting" our statements from top to bottom,
line by line. Therefore adding the following line:

```python
import module_name
```

Acts as a copying and pasting `cat.py` in our `main.py` at the top of the file.

Rad. Except when it's not. Most of the time, what we want to do when reusing
code this way is to **import the definitions**. In our example above we want to
get just the **Cat** definition, but we don't want to execute all those meows.

To do that, we need to go back to the original `cat.py` and make a few adjustments:

<CodeWave>

```python 1:32
class Cat:
  def __init__(self,
    oos_when_hungry,
    oos_when_playful,
    oos_when_open_door):
    self.oos_when_hungry = oos_when_hungry
    self.oos_when_playful = oos_when_playful
    self.oos_when_open_door = oos_when_open_door

  @staticmethod
  def meow(number_of_os):
    print("ฅ^•ﻌ•^ฅ Me" + "o" * number_of_os + "w")

  def open_the_door(self):
    Cat.meow(self.oos_when_open_door)

  def hungry(self):
    Cat.meow(self.oos_when_hungry)

  def i_wanna_play(self):
    Cat.meow(self.oos_when_playful)

  def equals(self, other_cat):
    if self.oos_when_hungry == other_cat.oos_when_hungry and \
      self.oos_when_playful == other_cat.oos_when_playful and \
      self.oos_when_open_door == other_cat.oos_when_open_door:
      return True
    else:
      return False

  def __equals__(self, other_cat):
    return self.equals(other_cat)


# Let me tell you about my girly kitty's morning
a = Cat(1, 4, 8)
a.open_the_door()
a.hungry()
a.i_wanna_play()

print()  # Let's add some space for readability. This line has nothing to do with the cats.

# Let me tell you about my big macho kitty
b = Cat(2, 10, 5)
b.open_the_door()
b.hungry()
b.i_wanna_play()

print()  # Let's add some space for readability. This line has nothing to do with the cats.

if a.equals(b):
  print("a == b Same Cat")
else:
  print("a == b Not the same Cat!")

print()  # Let's add some space for readability. This line has nothing to do with the cats.

if a.equals(a):
  print("a == a Same Cat")
else:
  print("a == a Not the same Cat!")

print()  # Let's add some space for readability. This line has nothing to do with the cats.

if b.equals(b):
  print("b == b Same Cat")
else:
  print("b == b Not the same Cat!")

print()  # Let's add some space for readability. This line has nothing to do with the cats.

if a == b:
  print("a == b It's the same cat!")
else:
  print("a == b It's not the same cat!")

print()  # Let's add some space for readability. This line has nothing to do with the cats.

if a == a:
  print("a == a It's the same cat!")
else:
  print("a == a It's not the same cat!")
```

First, let's review what we mean by "definitions":

```diff 1,2,11,14,17,20,23,31

```

A definition is every time we describe the behavior of a class, a method or a function.

```diff 34:40

```

Later on, we use these *definitions* when we instantiate/create objects of the class or when we invoke
those methods and functions.

```python 1:50
import cat

# Let me tell you about my girly kitty's morning
a = Cat(1, 4, 8)
a.open_the_door()
a.hungry()
a.i_wanna_play()

print()  # Let's add some space for readability. This line has nothing to do with the cats.

# Let me tell you about my big macho kitty
b = Cat(2, 10, 5)
b.open_the_door()
b.hungry()
b.i_wanna_play()

print()  # Let's add some space for readability. This line has nothing to do with the cats.

if a.equals(b):
  print("a == b Same Cat")
else:
  print("a == b Not the same Cat!")

print()  # Let's add some space for readability. This line has nothing to do with the cats.

if a.equals(a):
  print("a == a Same Cat")
else:
  print("a == a Not the same Cat!")

print()  # Let's add some space for readability. This line has nothing to do with the cats.

if b.equals(b):
  print("b == b Same Cat")
else:
  print("b == b Not the same Cat!")

print()  # Let's add some space for readability. This line has nothing to do with the cats.

if a == b:
  print("a == b It's the same cat!")
else:
  print("a == b It's not the same cat!")

print()  # Let's add some space for readability. This line has nothing to do with the cats.

if a == a:
  print("a == a It's the same cat!")
else:
  print("a == a It's not the same cat!")
```


We can reuse those definitions by "importing" them.


```diff 1:45

```


</CodeWave>

