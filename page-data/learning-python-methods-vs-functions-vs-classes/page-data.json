{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/learning-python-methods-vs-functions-vs-classes","result":{"data":{"post":{"__typename":"MdxPost","slug":"/learning-python-methods-vs-functions-vs-classes","title":"Learning Python | Methods vs Functions vs Classes","date":"15.04.2020","tags":[{"name":"python","slug":"python"},{"name":"learning","slug":"learning"}],"description":"A quick tour on the Python Language","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Learning Python | Methods vs Functions vs Classes\",\n  \"date\": \"2020-04-15T00:00:00.000Z\",\n  \"description\": \"A quick tour on the Python Language\",\n  \"tags\": [\"python\", \"learning\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Let's write a program that behaves like a cat. You like cats, right?\"), mdx(\"p\", null, \"My cat likes to wake up at 4:30 am, and start meowing. Apparently it's\\nimportant that everyone knows she's awake.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"print(\\\"Meow\\\")\\n\")), mdx(\"p\", null, \"That's good, but my cat does many other things. And meows in many different\\nways depending on her mood:\"), mdx(\"h3\", null, \"I'm going to teach you (my) cat's language:\"), mdx(\"h5\", null, \"I'm hungry\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"print(\\\"\\u0E05^\\u2022\\uFECC\\u2022^\\u0E05 Meow\\\")\\n\")), mdx(\"h5\", null, \"I'm wanna play!\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"print(\\\"\\u0E05^\\u2022\\uFECC\\u2022^\\u0E05 Meoooow\\\")\\n\")), mdx(\"h5\", null, \"Open the door you tirant!\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"print(\\\"\\u0E05^\\u2022\\uFECC\\u2022^\\u0E05 Meoooooooow\\\")\\n\")), mdx(\"p\", null, \"Yup. I have a very vocal kitty. Looking at the examples above that code seems\\nvery similar in all the cases: it starts with a cute \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/Emoticon#Japanese_style\"\n  }), \"kaomoji\"), \"\\nand then the phrase she wants to say in her language.\"), mdx(\"p\", null, \"So this is a program describing her morning:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"print(\\\"\\u0E05^\\u2022\\uFECC\\u2022^\\u0E05 Meoooooooow\\\")\\nprint(\\\"\\u0E05^\\u2022\\uFECC\\u2022^\\u0E05 Meow\\\")\\nprint(\\\"\\u0E05^\\u2022\\uFECC\\u2022^\\u0E05 Meoooow\\\")\\n\")), mdx(\"p\", null, \"It does look a bit repetitive... and it's hard to tell what it's doing. Let's try to make it a bit better by grouping\\nthe common code in a method.\"), mdx(\"h2\", null, \"What's a method?\"), mdx(\"p\", null, \"A method is way to call a piece of code used many times in different parts of the program.\"), mdx(\"h3\", null, \"Defining a method\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"def method_name():\\n  # method body\\n\")), mdx(\"p\", null, \"Let's stop for second and think about what \\\"defining\\\" means. If I ask you, what is \\\"walking\\\", how would you describe it?\\nIf someone asks me, I'd say \\\"walking is moving a number of steps\\\".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"def walking(number_of_steps):\\n  print(f\\\"moving {number_of_steps} steps\\\")\\n\")), mdx(\"p\", null, \"We've \\\"defined\\\" our first method! You might be pondering, what is that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"number_of_steps\"), \" doing there? Well, number of steps is something that can't be fixed. Imagine if walking was always \\\"moving 10 steps\\\". That would be annoying. Some days I walk 5K steps, other days 11K+ i.e. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"number_of_steps\"), \" is an \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"argument\"), \" (or \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"parameter\"), \") to our method. We also see the body of the method that prints a string with the number of steps we passed as an argument.\"), mdx(\"p\", null, \"Now that we know how to define methods, let's refactor our cat program by defining a method \\\"meow\\\":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"def meow(number_of_os):\\n  print(\\\"\\u0E05^\\u2022\\uFECC\\u2022^\\u0E05 Me\\\" + \\\"o\\\" * number_of_os + \\\"w\\\")\\n\")), mdx(\"p\", null, \"Awesome. We now have a way to describe what a meow is! But imagine if I would describe to you what \\\"eating an ice cream\\\" is and that would be it? You would never really experience it. To experience things you have to actually DO them, I'll buy you an ice cream when Rona \\uD83E\\uDDA0 is over.\"), mdx(\"p\", null, \"Anyway, how do we make methods do something in python? We \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"invoke\"), \" the methods. In python, you invoke methods by writing the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"method_name\"), \" followed by an open parenthesis \\\"(\\\" then \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"arguments\"), \" separated by commands and finally \\\")\\\". If there's no arguments, you write \\\"()\\\".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"def meow(number_of_os):\\n  print(\\\"\\u0E05^\\u2022\\uFECC\\u2022^\\u0E05 Me\\\" + \\\"o\\\" * number_of_os + \\\"w\\\")\\n\\nmeow(8)  # \\u0E05^\\u2022\\uFECC\\u2022^\\u0E05 Meoooooooow or \\\"Open the door you tirant!\\\"\\nmeow(1)  # \\u0E05^\\u2022\\uFECC\\u2022^\\u0E05 Meow or \\\"I'm hungry\\\"\\nmeow(4)  # \\u0E05^\\u2022\\uFECC\\u2022^\\u0E05 Meow or \\\"I'm wanna play!\\\"\\n\")), mdx(\"p\", null, \"That's a bit better. But those numbers confuse me. Reading this code makes me wonder what that means. Not ideal. It would be nice if we could just describe my cat's morning routing with more English like terms. Why don't we define methods that describe what she's saying?\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"def meow(number_of_os):\\n  print(\\\"\\u0E05^\\u2022\\uFECC\\u2022^\\u0E05 Me\\\" + \\\"o\\\" * number_of_os + \\\"w\\\")\\n\\ndef open_the_door():\\n  meow(8)\\n\\ndef hungry():\\n  meow(1)\\n\\ndef i_wanna_play():\\n  meow(4)\\n\\nopen_the_door()\\nhungry()\\ni_wanna_play()\\n\")), mdx(\"p\", null, \"It's more code. But it also makes things a bit clearer. An important thing to notice is that we're using our meow definition to define other actions! How cool is that? But we do that in English all the time, when I defined \\\"walking\\\" in English I had to use other definitions (like \\\"moving\\\" or \\\"number\\\" or \\\"steps\\\") that someone else defined at some point in history. That's exactly what we do all the time when we program.\"), mdx(\"p\", null, \"...I'm starting to feel bad about my other cat. I've spent a good chunk of this document talking about one of my cats, but not the other one... I'm a horrible cat dad.\"), mdx(\"p\", null, \"My male cat is a bit different. But he communicates in the same cat language as my girly kitty. He also asks to open doors, to say he's hungry and also to express his desire to play. But he doesn't make the exact same sounds. He still meows don't get me wrong, but he has his own particular \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"attributes\"), \". Wouldn't it be nice if we had a \\\"template\\\" for cats where we specify just what's different between them? Python to the rescue! Python and other programming languages have this concept of \\\"Class\\\" that behaves more or less like a template.\"), mdx(\"h2\", null, \"Defining a Class\"), mdx(\"p\", null, \"If I ask you: Define a \\\"tree\\\", what would you tell me? If someone asks me, I'd say: it's a \\\"plant\\\". That's a bit different from when we defined \\\"walking\\\", because walking was an action an a tree is a thing or noun. We define things in English by stating \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"attributes\"), \" about it. In python, we do it similarly:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"class Tree(Plant):  # a tree is a plant\\n  pass\\n\")), mdx(\"p\", null, \"Oftentimes, when we describe things, we want to use particular examples. If I tell you a tree is a plant that would be technically correct but it doesn't give you a good idea of what a tree is until you see one.\"), mdx(\"p\", null, \"I would probably say: \\\"Do you see that big plant with green leaves?\\\" that's a tree. But not all the trees have green leaves (like the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.countryliving.com/gardening/g3168/cherry-blossoms-facts/\"\n  }), \"cherry blossoms\"), \") or big (like the cute \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.bonsaitreegardener.net/care/how-to/small-leaves\"\n  }), \"bonsais\"), \"). \\\"That big plant with green leaves\\\" an \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"instance\"), \" of a tree. But the important thing is that we can describe a tree with those attributes! The caveat is that to make use of this Tree we need an actual example so we always have to create (or construct an instance).\"), mdx(\"p\", null, \"This is how we define a Tree, and how to create or construct one.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"class Plant:  # Let's ignore the details of plant for now\\n  pass\\n\\nclass Tree(Plant):  # a tree is a plant\\n  def __init__(self, size, color_of_leaves):  # we define how to construct a tree by using a reference to the new tree, its size and the color of its leaves\\n    self.size = size                          # a tree has a size\\n    self.color_of_leaves = color_of_leaves    # a tree's leaves are of a certain color\\n\\n\\nt = Tree(\\\"big\\\", \\\"green\\\")  # When we do this, python is invoking __init__(self, size, color_of_leaves) for us and returning it, and we assign that value to \\\"t\\\"\\n\")), mdx(\"p\", null, \"Note that constructing (or initializing) (that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__init__\"), \" method) has a reference to the object we're creating in the parameter \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"self\"), \". We use this \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"self\"), \" \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"argument\"), \" to set the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"attributes\"), \" that we will pass when we create a tree.\"), mdx(\"p\", null, \"Now that we now how to define a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Class\"), \" (our cat template!), let's continue with our cats program. Let's define a Cat class:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"class Cat:  # if you don't specify the base class, python assumes it comes from Object\\n  def __init__(self, oos_when_hungry, oos_when_playful, oos_when_open_door):  # the reference to the cat we're constructing (self), and the number of oos they use when meowing\\n    self.oos_when_hungry = oos_when_hungry\\n    self.oos_when_playful = oos_when_playful\\n    self.oos_when_open_door = oos_when_open_door\\n\")), mdx(\"p\", null, \"Sweet. We have described what a cat is. But... unlike our tree, our cats are very talkative! What does that mean? It means cats have actions too. How do we describe actions in python? well, with methods of course!\\nLet's ponder for a second, what does that mean? It means that things have \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"attributes\"), \" but also \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"methods\"), \". And now that we're here, let's start calling things with Python lingo: Python calls these things \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Objects\"), \".\\nThis is what \\\"Object Oriented Programming\\\" is: A way to describe \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"objects\"), \" which are data (\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"attributes\"), \") and behavior (\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"methods\"), \").\"), mdx(\"p\", null, \"Now, after that jargon... how do we \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"refactor\"), \" (reorganize code with a goal) the methods we already have? We have to follow a few steps:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"The first thing to do is, in python, if you want something to be part of something else, indent (add a tab) the text to the right. In visual studio code, you can do this by copying and pasting the three definitions (but not the invocations) and pasting it below the Cat class. Then you can press the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tab key\"), \" to indent the text.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Let's take look at the methods we have: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hungry\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"open_door\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i_wanna_play\"), \" call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"meow\"), \" but need each specific\\ncat's style of meowing (encoded as the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"number_of_oos\"), \" in ther meows). So we can use the values we stored when we constructed each cat:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\"\n  }), \"- def open_the_door():\\n+ def open_the_door(self):\\n-    meow(8)\\n+    meow(self.oos_when_open_door)\\n\\n- def hungry():\\n+ def hungry(self):\\n-   meow(1)\\n+   meow(self.oos_when_hungry)\\n\\n- def i_wanna_play():\\n+ def i_wanna_play(self):\\n-   meow(4)\\n+   meow(self.oos_when_playful)\\n\")))), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Red lines are before and green lines are the new changes. Please note that we're adding \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"self\"), \" to the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"arguments\"), \" of each method definition. Because we will need to refer to the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"attributes\"), \" from our Cat class.\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"What about the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"meow\"), \" method? Well, the meow method is a bit different. Every domestic cat in the world meows. It's not like my cats are unique in that. Also, it only takes \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"number_of_oos\"), \" as an \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"argument\"), \" and that's not part of our Cat definition, we pass that value when we invoke it from the other methods. Such methods that are not touch any parts of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"self\"), \" are called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"static methods\"), \". And we define them like this:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"class ClassName:\\n  @staticmethod\\n  def method_name(arguments):\\n    pass\\n\")), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"in the specific case of our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"meow\"), \" method:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"class Cat:  # if you don't specify the base class, python assumes it comes from Object\\n  def __init__(self, oos_when_hungry, oos_when_playful, oos_when_open_door):  # the reference to the cat we're constructing (self), and the number of oos they use when meowing\\n    self.oos_when_hungry = oos_when_hungry\\n    self.oos_when_playful = oos_when_playful\\n    self.oos_when_open_door = oos_when_open_door\\n\\n  @staticmethod\\n  def meow(number_of_os):\\n    print(\\\"\\u0E05^\\u2022\\uFECC\\u2022^\\u0E05 Me\\\" + \\\"o\\\" * number_of_os + \\\"w\\\")\\n\")), mdx(\"blockquote\", {\n    parentName: \"li\"\n  }, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Please note that static methods don't use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"self\"), \" because it doesn't need it! After these changes, our Cat class looks like this:\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"One final step, is to change the way we invoke \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"meow\"), \" in the other methods by adding the Class name (Cat in our case) when we invoke it:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\"\n  }), \"  def open_the_door(self):\\n-    meow(self.oos_when_open_door)\\n+    Cat.meow(self.oos_when_open_door)\\n\\n  def hungry(self):\\n-    meow(self.oos_when_hungry)\\n+    Cat.meow(self.oos_when_hungry)\\n\\n  def i_wanna_play(self):\\n-    meow(self.oos_when_playful)\\n+    Cat.meow(self.oos_when_playful)\\n\")))), mdx(\"p\", null, \"The reason we add \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Cat.\"), \" is because the static method is now a child of Cat, so we have to call it by its full name (the technical term is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fully qualified name\"), \"). Otherwise it would be impossible to differentiate it from regular methods in this python file.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"class Cat:\\n  def __init__(self, oos_when_hungry, oos_when_playful, oos_when_open_door):\\n    self.oos_when_hungry = oos_when_hungry\\n    self.oos_when_playful = oos_when_playful\\n    self.oos_when_open_door = oos_when_open_door\\n\\n  @staticmethod\\n  def meow(number_of_os):\\n    print(\\\"\\u0E05^\\u2022\\uFECC\\u2022^\\u0E05 Me\\\" + \\\"o\\\" * number_of_os + \\\"w\\\")\\n\\n  def open_the_door(self):\\n    Cat.meow(self.oos_when_open_door)\\n\\n  def hungry(self):\\n    Cat.meow(self.oos_when_hungry)\\n\\n  def i_wanna_play(self):\\n    Cat.meow(self.oos_when_playful)\\n\")), mdx(\"p\", null, \"So we have our Cat definition. Remember, we're just defining it. But to use it, we have to create/instatiate it. We intantiate objects from a class like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"class ClassName:\\n  def __init__(self):\\n    pass\\n\\n# Creating objects looks almost like invoking a function.\\n# In python, you can see that Classes always start with capital letters, so if you see something like below:\\nmy_object = ClassName() # it's creating/instantiating an object\\n\")), mdx(\"p\", null, \"In our feline world, our program now looks like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"class Cat:  # if you don't specify the base class, python assumes it comes from Object\\n  def __init__(self, oos_when_hungry, oos_when_playful, oos_when_open_door):  # the reference to the cat we're constructing (self), and the number of oos they use when meowing\\n    self.oos_when_hungry = oos_when_hungry\\n    self.oos_when_playful = oos_when_playful\\n    self.oos_when_open_door = oos_when_open_door\\n\\n  @staticmethod\\n  def meow(number_of_os):\\n    print(\\\"\\u0E05^\\u2022\\uFECC\\u2022^\\u0E05 Me\\\" + \\\"o\\\" * number_of_os + \\\"w\\\")\\n\\n  def open_the_door(self):\\n    Cat.meow(self.oos_when_open_door)\\n\\n  def hungry(self):\\n    Cat.meow(self.oos_when_hungry)\\n\\n  def i_wanna_play(self):\\n    Cat.meow(self.oos_when_playful)\\n\\n# Let me tell you about my girly kitty's morning\\na = Cat(1, 4, 8)\\na.open_the_door()\\na.hungry()\\na.i_wanna_play()\\n\\nprint()  # Let's add some space for readability. This line has nothing to do with the cats.\\n\\n# Let me tell you about my big macho kitty\\nb = Cat(2, 10, 5)\\n# He also does things in a different order...\\nb.i_wanna_play()\\nb.hungry()\\nb.open_the_door()\\n\")), mdx(\"h3\", null, \"How do I tell the two kitties apart?\"), mdx(\"p\", null, \"You may have noticed I didn't give the cats names, like every other python tutorial in the world. The reason is because in our discussion, the name hasn't been relevant to\\ndescribe my cats' routines. In fact, when we compare \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"objects\"), \" we do so based on their \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"attributes\"), \". We say this tree is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"bigger\"), \" than that one, this job \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"pays me less\"), \"\\nthan that other job. So... how do we encode that? In programming, there's many ways to achieve the same result, some solutions might be more appropriate than others (see? I\\nam comparing solutions \\uD83E\\uDD14) but let's try to solve this case with our current level of knowledge of python.\"), mdx(\"h3\", null, \"Defining a function\"), mdx(\"p\", null, \"When think about \\\"comparing\\\", what is that? Well, it's an action! And how do encode actions in python? With \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"methods\"), \". But in this case, this method is giving us\\ninformation back, we're not just printing stuff like in the methods we've used so far. In other words when we ask the question: \\\"do I like vanilla ice cream more than\\nchocolate?\\\" the information we get back is: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yes\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"no\"), \". Methods that return something are called \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"functions\"), \" and they look like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"def do_i_like_chocolate_more_than_vanilla():\\n  return True\\n\")), mdx(\"p\", null, \"In the example I hardcoded the value for my preference (it will always answer \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"True\"), \"). But you can return anything from a function: a number, a string, an object or\\neven another methods or functions. In summary: \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"functions\"), \" return information and all \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"functions\"), \" are \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"methods\"), \". So everything we have learned about \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"methods\"), \"\\napplies to \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"functions\"), \" too!\"), mdx(\"p\", null, \"With this new insight, let's teach our cats how to differentiate among themselves! I'll create a new \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"function\"), \" name \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"equals\"), \" in our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Cat class\"), \" that compares each\\n\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"attribute\"), \" of one cat with the other to see if they are the same cat:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"# I'm going to just show the code of equals here\\ndef equals(self, other_cat):\\n  if self.oos_when_hungry == other_cat.oos_when_hungry and\\n    self.oos_when_playful == other_cat.oos_when_playful and\\n    self.oos_when_open_door == other_cat.oos_when_open_door:\\n    return True\\n  else:\\n    return False\\n\")), mdx(\"p\", null, \"And the full \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Cat class\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"class Cat:  # if you don't specify the base class, python assumes it comes from Object\\n  def __init__(self, oos_when_hungry, oos_when_playful, oos_when_open_door):  # the reference to the cat we're constructing (self), and the number of oos they use when meowing\\n    self.oos_when_hungry = oos_when_hungry\\n    self.oos_when_playful = oos_when_playful\\n    self.oos_when_open_door = oos_when_open_door\\n\\n  @staticmethod\\n  def meow(number_of_os):\\n    print(\\\"\\u0E05^\\u2022\\uFECC\\u2022^\\u0E05 Me\\\" + \\\"o\\\" * number_of_os + \\\"w\\\")\\n\\n  def open_the_door(self):\\n    Cat.meow(self.oos_when_open_door)\\n\\n  def hungry(self):\\n    Cat.meow(self.oos_when_hungry)\\n\\n  def i_wanna_play(self):\\n    Cat.meow(self.oos_when_playful)\\n\\n  def equals(self, other_cat):\\n    if self.oos_when_hungry == other_cat.oos_when_hungry and \\\\\\n      self.oos_when_playful == other_cat.oos_when_playful and \\\\\\n      self.oos_when_open_door == other_cat.oos_when_open_door:\\n      return True\\n    else:\\n      return False\\n\\n# Let me tell you about my girly kitty's morning\\na = Cat(1, 4, 8)\\na.open_the_door()\\na.hungry()\\na.i_wanna_play()\\n\\nprint()  # Let's add some space for readability. This line has nothing to do with the cats.\\n\\n# Let me tell you about my big macho kitty\\nb = Cat(2, 10, 5)\\nb.open_the_door()\\nb.hungry()\\nb.i_wanna_play()\\n\\nprint()  # Let's add some space for readability. This line has nothing to do with the cats.\\n\\nif a.equals(b):\\n  print(\\\"a == b Same Cat\\\")\\nelse:\\n  print(\\\"a == b Not the same Cat!\\\")\\n\\nprint()  # Let's add some space for readability. This line has nothing to do with the cats.\\n\\nif a.equals(a):\\n  print(\\\"a == a Same Cat\\\")\\nelse:\\n  print(\\\"a == a Not the same Cat!\\\")\\n\\nprint()  # Let's add some space for readability. This line has nothing to do with the cats.\\n\\nif b.equals(b):\\n  print(\\\"b == b Same Cat\\\")\\nelse:\\n  print(\\\"b == b Not the same Cat!\\\")\\n\")), mdx(\"p\", null, \"You might be wondering, why can't I just do:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"if a == b:\\n  print(\\\"Same Cat\\\")\\n\")), mdx(\"p\", null, \"The fact is, you can! But not yet. Certain operations are common in programming, we've been using\\none already: constructing Objects. We have learned that to use objects you have to create them first,\\nit's so common that Python has a special syntax for it as the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__init__\"), \" method.\"), mdx(\"p\", null, \"Comparing objects is also very common in programming. We have to compare things when we want to see if\\nthey are equal, bigger or smaller, or when we're sorting them. So Python also has a special syntax for\\nthis behavior in the function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__equals__\"), \". Python exposes these common behaviors for objects\\nas \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"dunder methods/functions\"), \". Another example that you might remember is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__str__\"), \" which is a function\\nthat we use every time we want to see a string representation of an object.\"), mdx(\"p\", null, \"Let's see how could we implement \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"__equals__\"), \" for our cats program:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"def equals(self, other_cat):\\n  if self.oos_when_hungry == other_cat.oos_when_hungry and \\\\\\n    self.oos_when_playful == other_cat.oos_when_playful and \\\\\\n    self.oos_when_open_door == other_cat.oos_when_open_door:\\n    return True\\n  else:\\n    return False\\n\\ndef __equals__(self, other_cat):\\n  return self.equals(othercat)\\n\")), mdx(\"p\", null, \"We're just calling the other function, let's test this in the big program:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"class Cat:  # if you don't specify the base class, python assumes it comes from Object\\n  def __init__(self, oos_when_hungry, oos_when_playful, oos_when_open_door):  # the reference to the cat we're constructing (self), and the number of oos they use when meowing\\n    self.oos_when_hungry = oos_when_hungry\\n    self.oos_when_playful = oos_when_playful\\n    self.oos_when_open_door = oos_when_open_door\\n\\n  @staticmethod\\n  def meow(number_of_os):\\n    print(\\\"\\u0E05^\\u2022\\uFECC\\u2022^\\u0E05 Me\\\" + \\\"o\\\" * number_of_os + \\\"w\\\")\\n\\n  def open_the_door(self):\\n    Cat.meow(self.oos_when_open_door)\\n\\n  def hungry(self):\\n    Cat.meow(self.oos_when_hungry)\\n\\n  def i_wanna_play(self):\\n    Cat.meow(self.oos_when_playful)\\n\\n  def equals(self, other_cat):\\n    if self.oos_when_hungry == other_cat.oos_when_hungry and \\\\\\n      self.oos_when_playful == other_cat.oos_when_playful and \\\\\\n      self.oos_when_open_door == other_cat.oos_when_open_door:\\n      return True\\n    else:\\n      return False\\n\\n  def __equals__(self, other_cat):\\n    return self.equals(other_cat)\\n\\n# Let me tell you about my girly kitty's morning\\na = Cat(1, 4, 8)\\na.open_the_door()\\na.hungry()\\na.i_wanna_play()\\n\\nprint()  # Let's add some space for readability. This line has nothing to do with the cats.\\n\\n# Let me tell you about my big macho kitty\\nb = Cat(2, 10, 5)\\nb.open_the_door()\\nb.hungry()\\nb.i_wanna_play()\\n\\nprint()  # Let's add some space for readability. This line has nothing to do with the cats.\\n\\nif a.equals(b):\\n  print(\\\"a == b Same Cat\\\")\\nelse:\\n  print(\\\"a == b Not the same Cat!\\\")\\n\\nprint()  # Let's add some space for readability. This line has nothing to do with the cats.\\n\\nif a.equals(a):\\n  print(\\\"a == a Same Cat\\\")\\nelse:\\n  print(\\\"a == a Not the same Cat!\\\")\\n\\nprint()  # Let's add some space for readability. This line has nothing to do with the cats.\\n\\nif b.equals(b):\\n  print(\\\"b == b Same Cat\\\")\\nelse:\\n  print(\\\"b == b Not the same Cat!\\\")\\n\\nprint()  # Let's add some space for readability. This line has nothing to do with the cats.\\n\\nif a == b:\\n  print(\\\"a == b It's the same cat!\\\")\\nelse:\\n  print(\\\"a == b It's not the same cat!\\\")\\n\\nprint()  # Let's add some space for readability. This line has nothing to do with the cats.\\n\\nif a == a:\\n  print(\\\"a == a It's the same cat!\\\")\\nelse:\\n  print(\\\"a == a It's not the same cat!\\\")\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Let's write a program that behaves like a cat. You like cats, right? My cat likes to wake up at 4:30 am, and start meowing. Apparently it'sâ€¦","timeToRead":7,"banner":null}},"pageContext":{"slug":"/learning-python-methods-vs-functions-vs-classes","formatString":"DD.MM.YYYY"}}}