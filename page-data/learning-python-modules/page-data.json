{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/learning-python-modules","result":{"data":{"post":{"__typename":"MdxPost","slug":"/learning-python-modules","title":"Learning Python | Modules","date":"23.04.2020","tags":[{"name":"python","slug":"python"},{"name":"learning","slug":"learning"}],"description":"Python modules and how to tame them","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Learning Python | Modules\",\n  \"date\": \"2020-04-23T00:00:00.000Z\",\n  \"description\": \"Python modules and how to tame them\",\n  \"tags\": [\"python\", \"learning\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"When we build programs sometimes they get big. The same way\\nwe split little pieces of logic with \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/learning-python-methods-vs-functions-vs-classes\"\n  }), \"Methods, Functions and Classes\"), \"\\nwe might want to start segregating our code in multiple files, for\\nmany reasons, the most common one is to reuse a piece\\nof code that we already wrote. Let's see how all that works.\"), mdx(\"p\", null, \"When we writing the first few programs in earlier posts, we created\\na file named like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cat.py\"), \" and then keep appending more code at the end\\nof the file.\"), mdx(\"p\", null, \"Let's try to use our file in another program!\"), mdx(\"p\", null, \"Create a new file by opening a terminal and type:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"$ touch main.py\\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Note: Whenever you see $ at the beginning of commands it\\nmeans it should be typed in your terminal.\")), mdx(\"p\", null, \"Now let's add the following content to our file:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"import cat\\n\")), mdx(\"p\", null, \"Now let's run our new script:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"$ python main.py\\n\\u0E05^\\u2022\\uFECC\\u2022^\\u0E05 Meoooooooow\\n\\u0E05^\\u2022\\uFECC\\u2022^\\u0E05 Meow\\n\\u0E05^\\u2022\\uFECC\\u2022^\\u0E05 Meoooow\\n\\n\\u0E05^\\u2022\\uFECC\\u2022^\\u0E05 Meooooow\\n\\u0E05^\\u2022\\uFECC\\u2022^\\u0E05 Meoow\\n\\u0E05^\\u2022\\uFECC\\u2022^\\u0E05 Meoooooooooow\\n\\na == b Not the same Cat!\\n\\na == a Same Cat\\n\\nb == b Same Cat\\n\\na == b It's not the same cat!\\n\\na == a It's the same cat!\\n\")), mdx(\"p\", null, \"What we're seeing is the output of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cat.py\"), \". Why is that? When we use other imports\\nwe usually don't get this kind of output!\"), mdx(\"p\", null, \"When Python reads our file it starts \\\"interpreting\\\" our statements from top to bottom,\\nline by line. Therefore adding the following line:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"import module_name\\n\")), mdx(\"p\", null, \"Acts as a copying and pasting \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cat.py\"), \" in our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"main.py\"), \" at the top of the file.\"), mdx(\"p\", null, \"Rad. Except when it's not. Most of the time, what we want to do when reusing\\ncode this way is to \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"import the definitions\"), \". In our example above we want to\\nget just the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Cat\"), \" definition, but we don't want to execute all those meows.\"), mdx(\"p\", null, \"To do that, we need to go back to the original \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cat.py\"), \" and make a few adjustments:\"), mdx(CodeWave, {\n    mdxType: \"CodeWave\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\",\n    \"metastring\": \"1:32\",\n    \"1:32\": true\n  }), \"class Cat:\\n  def __init__(self,\\n    oos_when_hungry,\\n    oos_when_playful,\\n    oos_when_open_door):\\n    self.oos_when_hungry = oos_when_hungry\\n    self.oos_when_playful = oos_when_playful\\n    self.oos_when_open_door = oos_when_open_door\\n\\n  @staticmethod\\n  def meow(number_of_os):\\n    print(\\\"\\u0E05^\\u2022\\uFECC\\u2022^\\u0E05 Me\\\" + \\\"o\\\" * number_of_os + \\\"w\\\")\\n\\n  def open_the_door(self):\\n    Cat.meow(self.oos_when_open_door)\\n\\n  def hungry(self):\\n    Cat.meow(self.oos_when_hungry)\\n\\n  def i_wanna_play(self):\\n    Cat.meow(self.oos_when_playful)\\n\\n  def equals(self, other_cat):\\n    if self.oos_when_hungry == other_cat.oos_when_hungry and \\\\\\n      self.oos_when_playful == other_cat.oos_when_playful and \\\\\\n      self.oos_when_open_door == other_cat.oos_when_open_door:\\n      return True\\n    else:\\n      return False\\n\\n  def __equals__(self, other_cat):\\n    return self.equals(other_cat)\\n\\n\\n# Let me tell you about my girly kitty's morning\\na = Cat(1, 4, 8)\\na.open_the_door()\\na.hungry()\\na.i_wanna_play()\\n\\nprint()  # Let's add some space for readability. This line has nothing to do with the cats.\\n\\n# Let me tell you about my big macho kitty\\nb = Cat(2, 10, 5)\\nb.open_the_door()\\nb.hungry()\\nb.i_wanna_play()\\n\\nprint()  # Let's add some space for readability. This line has nothing to do with the cats.\\n\\nif a.equals(b):\\n  print(\\\"a == b Same Cat\\\")\\nelse:\\n  print(\\\"a == b Not the same Cat!\\\")\\n\\nprint()  # Let's add some space for readability. This line has nothing to do with the cats.\\n\\nif a.equals(a):\\n  print(\\\"a == a Same Cat\\\")\\nelse:\\n  print(\\\"a == a Not the same Cat!\\\")\\n\\nprint()  # Let's add some space for readability. This line has nothing to do with the cats.\\n\\nif b.equals(b):\\n  print(\\\"b == b Same Cat\\\")\\nelse:\\n  print(\\\"b == b Not the same Cat!\\\")\\n\\nprint()  # Let's add some space for readability. This line has nothing to do with the cats.\\n\\nif a == b:\\n  print(\\\"a == b It's the same cat!\\\")\\nelse:\\n  print(\\\"a == b It's not the same cat!\\\")\\n\\nprint()  # Let's add some space for readability. This line has nothing to do with the cats.\\n\\nif a == a:\\n  print(\\\"a == a It's the same cat!\\\")\\nelse:\\n  print(\\\"a == a It's not the same cat!\\\")\\n\")), mdx(\"p\", null, \"First, let's review what we mean by \\\"definitions\\\":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"1,2,11,14,17,20,23,31\",\n    \"1,2,11,14,17,20,23,31\": true\n  }), \"\")), mdx(\"p\", null, \"A definition is every time we describe the behavior of a class, a method or a function.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"34:40\",\n    \"34:40\": true\n  }), \"\")), mdx(\"p\", null, \"Later on, we use these \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"definitions\"), \" when we instantiate/create objects of the class or when we invoke\\nthose methods and functions.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\",\n    \"metastring\": \"1:50\",\n    \"1:50\": true\n  }), \"import cat\\n\\n# Let me tell you about my girly kitty's morning\\na = Cat(1, 4, 8)\\na.open_the_door()\\na.hungry()\\na.i_wanna_play()\\n\\nprint()  # Let's add some space for readability. This line has nothing to do with the cats.\\n\\n# Let me tell you about my big macho kitty\\nb = Cat(2, 10, 5)\\nb.open_the_door()\\nb.hungry()\\nb.i_wanna_play()\\n\\nprint()  # Let's add some space for readability. This line has nothing to do with the cats.\\n\\nif a.equals(b):\\n  print(\\\"a == b Same Cat\\\")\\nelse:\\n  print(\\\"a == b Not the same Cat!\\\")\\n\\nprint()  # Let's add some space for readability. This line has nothing to do with the cats.\\n\\nif a.equals(a):\\n  print(\\\"a == a Same Cat\\\")\\nelse:\\n  print(\\\"a == a Not the same Cat!\\\")\\n\\nprint()  # Let's add some space for readability. This line has nothing to do with the cats.\\n\\nif b.equals(b):\\n  print(\\\"b == b Same Cat\\\")\\nelse:\\n  print(\\\"b == b Not the same Cat!\\\")\\n\\nprint()  # Let's add some space for readability. This line has nothing to do with the cats.\\n\\nif a == b:\\n  print(\\\"a == b It's the same cat!\\\")\\nelse:\\n  print(\\\"a == b It's not the same cat!\\\")\\n\\nprint()  # Let's add some space for readability. This line has nothing to do with the cats.\\n\\nif a == a:\\n  print(\\\"a == a It's the same cat!\\\")\\nelse:\\n  print(\\\"a == a It's not the same cat!\\\")\\n\")), mdx(\"p\", null, \"We can reuse those definitions by \\\"importing\\\" them.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-diff\",\n    \"metastring\": \"1:45\",\n    \"1:45\": true\n  }), \"\"))));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"When we build programs sometimes they get big. The same way\nwe split little pieces of logic with  Methods, Functions and Classes \nwe mightâ€¦","timeToRead":1,"banner":null}},"pageContext":{"slug":"/learning-python-modules","formatString":"DD.MM.YYYY"}}}